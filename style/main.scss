@use 'sass:selector';
@use 'sass:string';
@use 'sass:list';

@mixin mode($mode) {
    $opposite-mode: '';

    @if $mode =='light' {
        $opposite-mode: 'dark';
    }

    @else {
        $opposite-mode: 'light';
    }

    $individual-selectors: selector.parse(&);

    $new-selectors: (
    );

// Split into individual selectors
@each $individual-selector in $individual-selectors {
    // Split by :: to find pseudo elements
    $parts: string.split(#{$individual-selector}, '::', 2);

    @if list.length($parts)>1 {
        // Selector has pseudo elements:
        // Split up the selector, apply mode modifier and stick the pseudo element on again
        $new-selectors: list.append($new-selectors,
                "#{selector.append(list.nth($parts, 1), ':where(:root:not([data-theme=#{$mode}]):not([data-theme=#{$opposite-mode}]) *)')}::#{list.nth($parts, 2)}",
                comma);
    }

    @else {
        // Selector has no pseudo elements: Simply append the :where() clause
        $new-selectors: list.append($new-selectors,
                selector.append($individual-selector, ':where(:root:not([data-theme=#{$mode}]):not([data-theme=#{$opposite-mode}]) *)'),
                comma);
    }
}

@media (prefers-color-scheme: $mode) {
    @at-root #{$new-selectors} {
        @content;
    }
}

@at-root #{$new-selectors} {
    @content;
}
}

@mixin light {
    @include mode('light') {
        @content;
    }
}

@mixin dark {
    @include mode('dark') {
        @content;
    }
}

// ================================

body {
    font-family: sans-serif;
    font-size: 1rem;
    // text-align: center;

    // matches data-theme="light" or data-theme="auto" with system instructing light mode
    @include light {
        background: white;
        color: black;
    }

    // matches data-theme="dark" or data-theme="auto" with system instructing dark mode
    @include dark {
        background: black;
        color: white;
    }
}

.json-row {
    font-family: monospace;

    .json-row {
        margin-left: 1.25rem;
    }

    .json-row:not(:has(a)) {
        margin-left: 2rem;
    }

    >.json-children {
        display: none;
    }

    >a>.arrow::after {
        display: inline-block;
        content: "â–º";
        transition: transform 100ms ease-in;

        margin-right: 0.2rem;
    }

    &.expanded {
        >.json-children {
            display: contents;
        }

        >a>.arrow::after {
            transform: rotate(90deg);
        }
    }

    >a {
        cursor: pointer;
        text-decoration: none;
    }

    >button {
        cursor: copy;
        border: none;
        background-color: #0000;

        padding: 0;
        margin: 0;
        margin-left: 0.5rem;
        vertical-align: middle;
        line-height: 0.5rem;

        transition: ease-in-out 75ms;

        @include light {
            color: black;
        }

        @include dark {
            color: white;
        }

        &:hover {
            @include light {
                color: #00008B;
            }

            @include dark {
                color: #23A0DB;
            }
        }

        &:active {
            transform: scale(0.9);
        }
    }
}

.key {
    @include light {
        color: #00008B;
    }

    @include dark {
        color: #23A0DB;
    }
}

.object::before {
    content: "Object";
}

.array {
    &::before {
        content: "Array[";
    }

    &::after {
        content: "]";
    }

    user-select: none;
}

.null {
    @include light {
        color: #855A00;
    }

    @include dark {
        color: #EEC97D;
    }
}

.bool {
    color: red;
}

.number {
    @include light {
        // color: blue;
        color: yellow;
    }

    @include dark {
        color: #66C2FF;
    }
}

.text {
    white-space: pre;
    word-wrap: break-word;

    @include light {
        color: green;
    }

    @include dark {
        color: #31F031;
    }
}